#include "UnityCG.cginc"

int BlurSamples;
int BlurDirection;
float BloomIntensity;
float BloomThreshold;
float HDRPower;

float2 SourceTextureResolution;

Texture2D<float4> Read_SourceTexture_Pass1;
Texture2D<float4> Read_SourceTexture_Pass2;
Texture2D<float4> Read_SourceTexture_Pass3;
Texture2D<float4> Read_SourceTexture_Pass4;

RWTexture2D<float4> Write_SourceTexture_Pass1;
RWTexture2D<float4> Write_SourceTexture_Pass2;
RWTexture2D<float4> Write_SourceTexture_Pass3;
RWTexture2D<float4> Write_SourceTexture_Pass4;

SamplerState _PointClamp;
SamplerState _LinearClamp;

float4 TEX2D(Texture2D<float4> tex, float2 uv)
{
    return tex.SampleLevel(_LinearClamp, uv, 0);
}

#define pow2(x) (x * x)

float gaussian(float2 i)
{
    float pi = atan(1.0) * 4.0;
    float sigma = float(BlurSamples) * 0.25;

    return 1.0 / (2.0 * pi * pow2(sigma)) * exp(-((pow2(i.x) + pow2(i.y)) / (2.0 * pow2(sigma))));
}

float4 blur(Texture2D<float4> tex, float2 uv)
{
    float2 scale = float2(1, 1) / SourceTextureResolution.xy;
    float2 offset = float2(0, 0);
    float4 col = float4(0, 0, 0, 0);
    float accum = 0.0;
    float weight = 0.0;

    for (int i = -(BlurSamples / 2); i <= BlurSamples / 2; ++i)
    {
        if (BlurDirection == 0)
            offset = float2(i, 0);
        else
            offset = float2(0, i);

        weight = gaussian(offset);

        col += tex.SampleLevel(_LinearClamp, uv + scale * offset, 0) * weight;

        accum += weight;
    }

    return col / accum;
}

//-------------------- THRESHOLD --------------------
#pragma kernel AdditiveBloom_Pass1
[numthreads(1, 1, 1)]
void AdditiveBloom_Pass1(uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy + float2(0.5, 0.5);
    uv /= SourceTextureResolution.xy;

    float4 originalColor = TEX2D(Read_SourceTexture_Pass1, uv);

    originalColor = pow(originalColor, 1.0f / HDRPower);
    originalColor -= BloomThreshold;

    //Color Space Correction
    //originalColor = float4(LinearToGammaSpace(originalColor), originalColor.a);
    Write_SourceTexture_Pass1[id.xy] = originalColor;
}

//-------------------- BLUR HORIZONTAL --------------------
#pragma kernel AdditiveBloom_Pass2
[numthreads(1, 1, 1)]
void AdditiveBloom_Pass2(uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy + float2(0.5, 0.5);
    uv /= SourceTextureResolution.xy;

    BlurDirection = 0;
    float4 originalColor = blur(Read_SourceTexture_Pass2, uv);

    //Color Space Correction
    //originalColor = float4(LinearToGammaSpace(originalColor), originalColor.a);
    Write_SourceTexture_Pass2[id.xy] = originalColor;
}

//-------------------- BLUR VERTICAL --------------------
#pragma kernel AdditiveBloom_Pass3
[numthreads(1, 1, 1)]
void AdditiveBloom_Pass3(uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy + float2(0.5, 0.5);
    uv /= SourceTextureResolution.xy;

    BlurDirection = 1;
    float4 originalColor = blur(Read_SourceTexture_Pass3, uv);

    //Color Space Correction
    //originalColor = float4(LinearToGammaSpace(originalColor), originalColor.a);
    Write_SourceTexture_Pass3[id.xy] = originalColor;
}

//-------------------- COMPOSITE --------------------
#pragma kernel AdditiveBloom_Pass4
[numthreads(1, 1, 1)]
void AdditiveBloom_Pass4(uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy + float2(0.5, 0.5);
    uv /= SourceTextureResolution.xy;

    float4 originalColor = TEX2D(Read_SourceTexture_Pass1, uv);
    float4 bloomColor = TEX2D(Read_SourceTexture_Pass3, uv);

    bloomColor = pow(bloomColor, HDRPower);
    bloomColor *= BloomIntensity;

    originalColor += max(0.0f, bloomColor);

    //Color Space Correction
    originalColor = float4(LinearToGammaSpace(originalColor), originalColor.a);
    Write_SourceTexture_Pass4[id.xy] = originalColor;
}